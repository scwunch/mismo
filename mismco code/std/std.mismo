struct Array[T]
  var _buffer: Pointer[T]
  var _len: UInt
  var _cap: UInt

  def len UInt: _len
  def cap UInt: _cap

  def opt(index: UInt) -> let Option[let T]:
    if index < _len
      Some(_buffer.deref(index))
    else
      None

  def mut opt(index: UInt): mut Option[mut T]
    if index < _len
      Some(_buffer.deref_mut(index))
    else
      None
    
  def get(index: UInt): let T
    _buffer.deref(index)
  
  def mut get(index: UInt): mut T
    _buffer.deref_mut(index)

struct Array[T]
  var _buffer: Pointer[T]
  var _len: UInt
  var _cap: UInt

  def 
    len UInt: _len
    cap UInt: _cap

    opt(index: UInt): let Option[let T]
      if index < _len:
        Option.Some(_buffer.deref(index))
      else:
        None

    mut opt(index: UInt): mut Option[mut T]
      if index < _len
        Some(_buffer.deref_mut(index))
      else
        None
    
    get(index: UInt): let T
      _buffer.deref(index)
  
    mut get(index: UInt): mut T
      """ panics """
      _buffer.deref_mut(index)
    

enum Result[T, E]
  Ok(T)
  Err(E)


enum Option[T]
  Some(T)
  None

trait Monad[T]
  def map[U](fn: T -> U) Self[U]

  def flat_map[U](fn: T -> Self[U]) Self[U]


extend[T] Option[T] is Monad[T]
  def map[U](fn: T -> U) Option[U]
    if self is
      Some(t): Some(fn(t))
      None: None


-- binding downcast functions
def[T]
  as_mut(mut self T) -> mut T:
    self
  
  as_let(self T) -> let T:
    self
  
  to_ref(move self T) -> ref T:
    self
  
  to_box(move self T) -> box T:
    self

trait Iterator[T]
  def next -> Option[T]

trait Iterable[T, Iter: Iterator[T]]
  def iter -> Iter

extend[T] Array[T] is Iterable[T, ArrayIterator[T]]
  def iter -> ArrayIterator[T]:
    ArrayIterator(self)


struct ArrayIterator[T]
  var _array: #T Array[T]
  var _index: UInt

  constructor(#T array: Array[T]):
    _array = array
    _index = 0

  def mut next -> Option[T]
    if _index < _array.len
      Option.Some(_array.get(_index += 1))
    else
      Option.None



def main:
  var array = [1, 2, 3]
  var iter = array.iter
  


---
binding restriction notations:
<no annotation> => any binding
let: only let binding
let+: let/ref binding
ref: only ref binding
mut: only mut binding
mut+: mut/box/var binding
box+: box/var binding
store: box/ref/var binding
var: var binding
#T+: binding that is a super-type of T's binding


...
share: let/mut/box/ref
mut+: mut/box/var
store: box/ref/var
send: var/ref









-- 100 doors
fn main:
  var doors = Array[Bool].new(100)
  for pass in 1..=100:
    for door in 1..=100:
      if door % pass == 0:
        doors.set(door - 1, not doors.get(door - 1))
  print(doors)
    










-- Intersecting Number Wheels
fn main:
  var wheels = get_input
    .split('\n')
    .map(line => Wheel(line))
  for n in 1..=20:
    print(wheels.get(0).next(wheels))
  
struct Wheel
  var name: Char
  var spokes: Array[Spoke]
  var index: UInt = 0

  constructor(text String):
    name = text.get(0)
    var i UInt
    for i in 2..text.count:
      if text.get(i).is_whitespace: 
        break

    spokes = (i..text.count)
      .map(char => Spoke(char))
      .to_array

  fn next(wheels: Array[Wheel]) UInt:
    if spokes.get(
      index = (index + 1) % spokes.count
    ) is
      Spoke.Number(num):
        num
      Spoke.Name(name):
        wheels.get(name).next(wheels)
      

enum Spoke
  Number(UInt)
  Name(Char)

  constructor(char Char): self = 
    if char.is_digit:
      Spoke.Number(char.UInt)
    else:
      Spoke.Name(char)
    

extend Array[Wheel]
  fn get(char Char): Option[Wheel]
    for wheel in self:
      if wheel.name == char:
        return Option.Some(wheel)
    Option.None
    
  
struct Array[T]
  var _buffer: Pointer[T]
  var _len: UInt
  var _cap: UInt

  def len UInt: _len
  def cap UInt: _cap

  def opt(index: UInt): Option[T]
    if index < _len
      Some(_buffer.deref(index))
    else
      None

  def mut opt(index: UInt): Option[T]
    if index < _len
      Some(_buffer.deref_mut(index))
    else
      None
    
  def get(index: UInt): T
    _buffer.deref(index)
  
  def mut get(index: UInt): T
    _buffer.deref_mut(index)

struct Array[T]
  var _buffer: Pointer[T]
  var _len: UInt
  var _cap: UInt

  def 
    len UInt: _len
    cap UInt: _cap

    opt(index: UInt): Option[T]
      if index < _len:
        Option.Some(_buffer.deref(index))
      else:
        None

    mut opt(index: UInt): Option[T]
      if index < _len
        Some(_buffer.deref_mut(index))
      else
        None
    
    get(index: UInt): T
      _buffer.deref(index)
  
    mut get(index: UInt): T
      """ panics """
      _buffer.deref_mut(index)
    

enum Result[T, E]
  Ok(T)
  Err(E)


alias Option[T] = Result[T, Nil]
  static Some[T](t: T) Option[T]: 
    Ok(t)
  static None[T] Option[T]: 
    Err(Nil)


trait Monad[T]
  def map[U](fn: T -> U) Self[U]

  def flat_map[U](fn: T -> Self[U]) Self[U]


extend[T] Option[T] is Monad[T]
  def map[U](fn: T -> U) Option[U]
    if self is
      Ok(t): Ok(fn(t))
      Err(_): Err(Nil)


-- 100 doors
fn main:
  var doors = Array[Bool].new(100)
  for pass in 1..=100:
    for door in 1..=100:
      if door % pass == 0:
        doors.set(door - 1, not doors.get(door - 1))
  print(doors)
    










-- Intersecting Number Wheels
fn main:
  var wheels = get_input
    .split('\n')
    .map(line => Wheel(line))
  for n in 1..=20:
    print(wheels.get(0).next(wheels))
  
struct Wheel
  var name: Char
  var spokes: Array[Spoke]
  var index: UInt = 0

  constructor(text String):
    name = text.get(0)
    var i UInt
    for i in 2..text.count:
      if text.get(i).is_whitespace: 
        break

    spokes = (i..text.count)
      .map(char => Spoke(char))
      .to_array

  fn next(wheels: Array[Wheel]) UInt:
    if spokes.get(
      index = (index + 1) % spokes.count
    ) is
      Spoke.Number(num):
        num
      Spoke.Name(name):
        wheels.get(name).next(wheels)
      

enum Spoke
  Number(UInt)
  Name(Char)

  constructor(char Char): self = 
    if char.is_digit:
      Spoke.Number(char.UInt)
    else:
      Spoke.Name(char)
    

extend Array[Wheel]
  fn get(char Char): Option[Wheel]
    for wheel in self:
      if wheel.name == char:
        return Option.Some(wheel)
    Option.None
    
  
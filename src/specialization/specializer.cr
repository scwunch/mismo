class Specializer
  property env : TypeEnv
  property queue = [] of Monomorphization
  property functions = {} of String => Array(Function)

  def initialize(@env : TypeEnv)
  end
  def initialize(@env : TypeEnv, main_func : Ast::Function)
    @env = env
    main_def = env.function_defs[main_func.name][0]
    get_or_make_function(Location.zero, main_def, Slice(Type).empty, 0)
  end

  def log
    env.log
  end

  def run
    type_checker = TypeContext.new(env, self)
    while mono = queue.shift?
      raise "WAHT" if mono.function.name.starts_with?("__zig_")
      body = type_checker.type_check_function(mono.function, mono.type_params, mono.type_args, mono.body)
      if body.nil?
        next
      end
      mono.function.body = body
    end
  end

  def new_function(function_def : FunctionDef, type_args : Slice(Type))
    overloads = functions[function_def.name]? || (
      functions[function_def.name] = [] of Function
    )
    index = overloads.size
    function = Function.new(function_def, type_args, index)
    overloads << function
    function
  end

  def find_function?(function_def : FunctionDef, type_args : Slice(Type)) : Function?
    if overloads = functions[function_def.name]?
      return overloads.find { |f| 
        f.function_def == function_def && f.type_args == type_args 
      }
    end
    nil
  end

  # return the newly pushed function
  def get_or_make_function(location : Location, function_def : FunctionDef, type_args : Slice(Type), ast_overload_index : Int32) : Function
    if function = find_function?(function_def, type_args)
      # function is already processed or queued for processing
      return function
    end
    function = new_function(function_def, type_args)
    return function if function_def.extern?
    raise "WAHT" if function.name.starts_with?("__zig_")
    # Okay, so the problem is here is that functions that are generated by the TypeEnv
    # (eg constructors) are not in the ast_functions hash, so we need to handle that case
    unless ast_funcs = env.ast_functions[function_def.name]?
      log.warning(location, "W#{__LINE__} no AST found for function #{function_def.name}; cannot specialize")
      return function
    end
    unless body = ast_funcs[ast_overload_index]?.try &.body
      log.warning(location, "W#{__LINE__} no AST found for overload #{ast_overload_index} of function #{function_def.name}; cannot specialize")
      return function
    end
    queue << Monomorphization.new(
        function, 
        function_def.type_params, 
        type_args, 
        body
    )
    function
  end
end

struct Monomorphization
  property function : Function
  property type_params : Slice(TypeParameter)
  property type_args : Slice(Type)
  property body : Ast::Expr
  def initialize(@function : Function, @type_params : Slice(TypeParameter), @type_args : Slice(Type), @body : Ast::Expr)
  end
end